{
  "pretest": {
    "title": "Rod Cutting Problem - Pre-Test",
    "description": "Test your understanding of Dynamic Programming concepts and the Rod Cutting problem before starting the simulation.",
    "duration": "10 minutes",
    "passing_score": 60,
    "questions": [
      {
        "id": 1,
        "question": "What is the fundamental principle behind Dynamic Programming?",
        "options": [
          "Solving problems by dividing them into independent subproblems and solving each separately",
          "Solving overlapping subproblems once and storing their solutions for reuse",
          "Using multiple processors to solve problems in parallel",
          "Randomly trying different solutions until finding the optimal one"
        ],
        "correct": 1,
        "explanation": "Dynamic Programming works by identifying overlapping subproblems, solving each subproblem exactly once, and storing the results (memoization) to avoid redundant computations. This is what makes DP efficient compared to naive recursive approaches."
      },
      {
        "id": 2,
        "question": "In the Rod Cutting Problem, if you have a rod of length 5, how many different ways can you cut it (including not cutting at all)?",
        "options": [
          "5 ways",
          "10 ways",
          "16 ways",
          "32 ways"
        ],
        "correct": 2,
        "explanation": "For a rod of length n, there are 2^(n-1) ways to cut it. For n=5, that's 2^4 = 16 ways. At each of the 4 possible cutting positions between units, you can choose to cut or not cut, giving 2×2×2×2 = 16 combinations."
      },
      {
        "id": 3,
        "question": "Which of the following real-world problems is NOT analogous to the Rod Cutting Problem?",
        "options": [
          "Cutting fabric rolls to maximize profit in a textile factory",
          "Allocating server time slots to different clients for maximum revenue",
          "Finding the shortest path between two cities on a map",
          "Dividing an investment budget across different time periods for maximum returns"
        ],
        "correct": 2,
        "explanation": "The shortest path problem is fundamentally different—it's about minimization and finding a path through a graph, not about partitioning a resource. Rod Cutting is an optimization problem about partitioning (cutting, allocating, dividing) to maximize value."
      },
      {
        "id": 4,
        "question": "What would happen if we tried to solve the Rod Cutting Problem for a rod of length 25 using naive recursion without memoization?",
        "options": [
          "It would complete in milliseconds since modern computers are very fast",
          "It would take an impractically long time due to exponential growth of computations",
          "It would give an incorrect answer due to integer overflow",
          "It would complete quickly because recursion is always efficient"
        ],
        "correct": 1,
        "explanation": "Naive recursion would result in O(2^n) time complexity. For n=25, that's 2^25 = 33,554,432 recursive calls with massive redundancy. Even on modern computers, this would take significant time, making it impractical. This is why DP is necessary."
      },
      {
        "id": 5,
        "question": "In the context of Rod Cutting, what does 'optimal substructure' mean?",
        "options": [
          "The problem can be solved by choosing random cuts until finding the best solution",
          "The optimal solution to the problem contains optimal solutions to its subproblems",
          "The problem requires dividing the rod into equal-sized pieces",
          "The problem can only be solved using a specific cutting pattern"
        ],
        "correct": 1,
        "explanation": "Optimal substructure means that an optimal solution to the main problem (best way to cut rod of length n) can be constructed from optimal solutions to smaller subproblems (best ways to cut rods of length less than n). This property is essential for DP to work."
      }
    ]
  }
}